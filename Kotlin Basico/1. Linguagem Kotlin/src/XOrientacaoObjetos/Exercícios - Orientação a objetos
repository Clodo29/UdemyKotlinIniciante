1 - Quais são as duas características comuns entre objetos do mundo real e objetos de software?
a. Dados e Estilos
b. Atributos e Caracteristicas
c. Atributos e Comportamentos
d. Comportamentos e Ações

Resposta:
C - Assim como um objeto do mundo real, atributos de software também possuem atributos (variáveis) e comportamentos (funções).

2 - Complete a seguinte frase:
Um objeto _______ guarda seus atributos em _______ e seu ___ é representado por métodos ou funções.
a. do mundo real, variáveis, comportamento
b. do mundo real, funções, comportamento
c. de software, constantes, comportamento
d. de software, variáveis, comportamento

Resposta:
D - Os objetos de software, são muito similares aos objetos do mundo real, eles também possuem atributos e comportamentos! Um objeto de software guarda seus atributos em variáveis e seu comportamento é representado por métodos ou funções.

3 - O correto, é modelarmos os objetos de forma que a interação entre eles seja feita apenas por meio de:
a. Funções
b. Atributos
c. Variáveis
d. Construtores

Resposta:
A - Os objetos interagem entre si por meio dos métodos/funções que manipulam seus atributos, nem todos os atributos de nosso objeto podem ser alterados diretamente, muita vezes devemos permitir seu acesso apenas via funções e manipularmos seu valor internamente.

4 - Conceito de deixar o atributo interno do objeto invisível e permitir que toda interação seja feita apenas via métodos / funções, é chamado de:
a. Data hiding
b. Encapsulation hiding
c. Data Encapsulation
d. Encapsulation

Resposta:
A e C - O conceito de deixar o atributo interno do nosso objeto invisível e permitir que toda interação seja feita apenas via métodos / funções é chamado de “data hiding ou encapsulation” (encapsulamento de dados).

5 - Conceito de deixar o atributo interno do objeto invisível e permitir que toda interação seja feita apenas via métodos / funções, é chamado de:
a. Data hiding
b. Encapsulation hiding
c. Data Encapsulation
d. Encapsulation

Resposta:
A e D - Este conceito de deixar o atributo interno do nosso objeto invisível e permitir que toda interação seja feita apenas via métodos / funções é chamado de “data hiding ou encapsulation” (encapsulamento de dados).

6 - Quando falamos que um objeto pode ser escrito e mantido independente dos outros objetos, estamos nos referindo a:
a. Orientação a Objetos
b. Reuso de Código
c. Modularidade
d. Encapsulamento

Resposta:
C - Apenas alternativa 3 está correta, quando criamos nosso sistema bem dividido e temos um projeto de classes muito bem definido, temos maior facilidade em mantê-lo independente de outros sistemas.
7 - Sobre reuso de código, selecione todas as alternativas corretas:
a. Um objeto pode ser usado em várias partes do nosso sistema
b. Trechos de código, podem ser copiados para várias partes do nosso sistema
c. Uma classe que definimos pode ser utilizada por outro programador para criar seus objetos
d. Reuso de código facilita muito pois podemos copiar trechos que outros programadores já fizeram, proporcionando mais agilidade ao desenvolvimento.

Resposta:
A e C - Quando falamos sobre Reuso de Código, não estamos nos referindo a "copiar trechos" para reutilizá-los, estamos nos referindo a utilização por meio de referênciarmos para classes, métodos, funções já existentes, podemos chamar trechos e utilizá-los, sem ter o retrabalho de criar / copiar o que já está desenvolvido.

8 - Caso um objeto específico do sistema começar a dar problema, o que podemos fazer para que o sistema volte a funcionar corretamente?
a. Substituir o sistema por outro
b. Corrigir apenas o local específico onde o problema está ocorrendo, apenas o objeto que apresenta erro
c. Reiniciar a máquina onde o sistema está executando
d. Atualizar o ambiente em que o sistema executa: sistema operacional, hardware, versões das apis, etc

Resposta:
Lembre-se quando expliquei que um dos benefícios que temos ao utilizarmos O.O corretamente é a
facilidade para debugar / substituir: se um objeto específico do sistema começa a dar problema, você pode simplesmente substituí-lo por outro objeto que solucione o problema funcione da mesma forma que ele funcionava para os outros objetos.
Isto é bem parecido com o mundo real, se o motor do nosso carro está com problemas e precisa ser trocado, nós apenas trocamos o motor por um que se encaixe em nosso carro, não precisamos trocar todo o carro.

9 - É correto afirmar que uma classe é gerada a partir de um objeto?
a. Sim
b. Não
Resposta:
Não é correto, na verdade é o contrário. Nossos objetos são gerados a partir de nossas classes.
Classe é o modelo pelo qual são gerados nossos objetos (instâncias).

10 - As variáveis que declaramos dentro de nossa classe Kotlin são:
a. Atributos
b. Campos
c. Fields
d. Propriedades

Resposta:
D - Conforme foi dito em aula, uma classe possui propriedades. No Kotlin não temos field como no java, tudo que declaramos já são propriedades.

11 - No Kotlin, já são criados implicitamente os métodos get e set quando declaramos nossas propriedades.
a. Verdadeiro
b. Falso

Resposta:
A - Ao definirmos a variável dentro de nossa classe, já são criados implicitamente o get e set, e não precisamos ficar definindo como no java. (Por serem propriedades, os métodos de acesso já são criados para elas).

12 - Para criarmos propriedades que podem apenas serem lidas na nossa classe, o que temos que utilizar?
a. var
b. final var
c. val
d. constant val

Resposta:
C - Quando criamos uma val, estamos criando uma variável imutável, ou seja, que após atribuído valor a ela, não poderá mais ser alterado.

13 - Uma classe pode conter um ou mais construtores.
a. Verdadeiro
b. Falso

Resposta:
A - Verdadeiro! Podemos criar um construtor primário, que é o que declaramos após a definição da nossa classe e também podemos incluir um ou mais construtores secundários, que são definidos a partir da palavra "constructor". Veja mais aqui: https://kotlinlang.org/docs/reference/classes.html#constructors

14 - Para iniciar os valores das propriedades de nossa classe, podemos utilizar qualquer um dos construtores que ela possua.
a. Verdadeiro
b. Falso

Resposta:
A - Verdadeiro! Podemos criar um objeto a partir de nossa classe usando qualquer um de seus construtores.

15 - O que precisamos incluir na nossa classe para que algo já seja executado ao criarmos nosso objeto?
a. start
b. exec
c. init
d. step

Resposta:
C - Ao incluirmos um init na nossa classe, podemos dentro dele executarmos ações no momento em que nossa classe é instanciada (no momento da criação do nosso objeto).
Veja mais em: https://kotlinlang.org/docs/reference/classes.html#constructors

16 - Podemos utilizar um ___ após a declaração da nossa propriedade para que ela fique apenas com acesso de leitura.
a. private var
b. private val
c. private get
d. private set

Resposta:
D - A instrução correta que devemos utilizar é a private set. Colocando esta instrução após a declaração da propriedade, estamos limitando seu acesso, deixando aberto apenas o get, para lermos o valor.

17 - Selecione todos os métodos que já são implementados por padrão quando criamos uma data class:
a. equals()
b. hashCode()
c. toString()
d. copy

Resposta:
Todas as alternativas estão corretas, você pode conferir mais sobre o assunto neste link oficial: https://kotlinlang.org/docs/reference/data-classes.html

18 - Uma data class precisa ter no mínimo quantos parâmetros no seu construtor primário?
a. Não tem valor mínimo, pode ser declarada sem parâmetros
b. No mínimo 1
c. No mínimo 2
d. No mínimo 3

Resposta:
O construtor precisa de pelo menos 1 parâmetro e ele deve ser declarado usando var ou val.
Veja mais sobre o assunto: https://kotlinlang.org/docs/reference/data-classes.html

19 - Podemos utilizar uma data class para transferir dados entre classes / camadas da nossa aplicação.
a. Verdadeiro
b. Falso

Resposta:
A - Sim, o uso de uma data class é sugerido quando queremos carregar um objeto com dados que precisam transitar entre outras classes e camadas de nossa aplicação. Como foi apresentado na aula, uma data class já cria automaticamente vários métodos úteis como toString, copy, equals e hashCode.

20 - Com herança temos uma classe mais genérica (pai) e classes que herdem dela, mais específicas (sua filhas).
a. Verdadeiro
b. Falso

Resposta:
Verdadeiro. Quando herdamos de uma classe, podemos dizer que ela é a classe pai, e a classe que herdou, torna-se a classe filha.

21 - Por padrão todas as classes em kotlin são _____.
a. open
b. private
c. public
d. final

Resposta:
D - Quando criamos por padrão ela sempre é final! Mesmo não colocamos explicitamente a palavra final, kotlin assume que ela é final. Veja mais sobre este assunto aqui: https://kotlinlang.org/docs/reference/classes.html

22 - Quando herdamos de uma classe podemos utilizar todas suas caracteristicas e comportamentos.
a. Verdadeiro
b. Falso

Resposta:
Verdadeiro. A classe filha herda as propriedades e comportamentos da classe pai.

23 - Qual das seguintes alternativas defini corretamente o que é uma classe?
a. Classe é um arquivo que deve possuir objetos, atributos e funções.
b. Classe é uma instância de um Objeto.
c. Classe é um objeto que podemos utilizar para criar várias outros tipos de objetos.
d. Classe é um molde, uma receita, a partir dela são gerados os objetos.

Resposta:
D - Alternativa 4, a classe é nosso molde, lembre-se dos exemplos das aulas, onde definimos algumas classes e objetos.

24 - Qual é a sintaxe correta para declarar uma classe no Kotlin?
a. class <nome>
b. public class <nome>
c. declare class <nome>
d. instance class <nome>

Resposta:
Para declararmos uma classe em Kotlin é muito simples, basta digitarmos a palavra class seguida pelo nome da classe.
Veja mais sobre classes neste link: https://kotlinlang.org/docs/reference/classes.html

25 - Qual palavra temos que utilizar se quisermos chamar uma função da classe que estamos herdando (a classe pai)?
a. above
b. upper
c. over
d. super

Resposta:
D - Alternativa 4 é a correta! Sempre que quisermos chamar algo que é da classe que herdamos, utilizamos a palavra super para acessá-la.

26 - Fazemos _________ quando definimos funções com o mesmo nome e tipos diferentes de argumentos e ____________ quando reescrevemos a mesma função com os mesmos argumentos e anotamos com a anotação override.
a. sobrescrita, sobrecarga
b. sobrecarga, sobrescrita
c. herança, sobrecarga
d. sobrescrita, herança

Resposta:
B - Podemos sobrecarregar funções quando quisermos disponibilizar a mesma função com outra assinatura, possibilitando chamá-la de diferentes formas. Podemos também sobrescrever determinadas funções, implementando o seu funcionamento como bem entendermos.

27 - Considere o seguinte código:
abstract class Student(name: String) : Person(name) {
override fun print() = println("Eai, blz $name?")
abstract fun delete() = "Ok - removido"
}
Assinale a alternativa correta:
a. Todas as classes que herdarem da classe Student terão que implementar a função delete()
b. Todas as classes que herdarem da classe Student não poderão alterar o comportamento "delete", poderão apenas utilizar
c. O código não compila pois como a função foi definida como abstrata, ela não deveria possuir um corpo
d. Todas as classes que herdarem da classe Student, poderão ou não implementar a função delete. Caso implementem, poderão definir seu próprio corpo, caso contrário, será utilizada a função da classe pai

Resposta:
C - Funções abstratas não possuem corpo. Elas devem ser implementadas por quem estiver herdando da classe abstrata. Para que este código funcionasse, teríamos que remover a partir do igual: abstract fun delete()

28 - O modificador de acesso _______ limita o aceso a variável apenas dentro da própria classe.
O modificador de acesso _______ permite que a variável seja alterada por qualquer classe que herde da classe.
O modificador de acesso _______ permite que a variável seja acessada de qualquer lugar, por qualquer objeto.
a. final, protected, public
b. private, protected, open
c. private, protected, public
d. private, open, public

Resposta:
C - Cada um dos modificadores controlam o acesso as propriedades / funções de uma classe. Temos desde o modificador mais restrito (private) até o mais aberto (public). Veja mais sobre modificadores: https://kotlinlang.org/docs/reference/visibility-modifiers.html

29 - É correto afirmar que podemos criar uma função para classes já existentes, adicionando novos comportamentos a ela?
a. Sim
b. Não

Resposta:
a - Com certeza podemos! Kotlin nos permite incluir métodos para classes já existentes facilmente,
basta colocamos o nome da classe.nomeFuncao e implementarmos a funcionalidade que desejarmos.

11 - Podemos declarar mais de uma classe dentro de um arquivo do Kotlin.
a. Sim
b. Não

Resposta:
a. Sim, o Kotlin permite declararmos várias classes dentro de um arquivo, não é como no Java, que um arquivo tem ter o mesmo nome da classe, podemos ter qualquer arquivo com muitas classes dentro dele.